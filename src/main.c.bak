/*
 * Main function
 * Project: Aerial
 * Developer: Aer
 */

#include "main.h"

// Generates a random double between a and b
double random(double a, double b) {
  return (rand()/(double)RAND_MAX) * (b-a) + a;
}

double inv_mass(double w)
{
  if (w == 0)
    return 0;
  return (1/w);
}

// Calculates the reflection vector and returns the effect on velocity
Vector2 reflectionV(int a, int b, Vector2 v, double e, double mA, double mB)
{
  Vector2 Vect = malloc(sizeof(Vector2));
  Vect->X = ((1+e)*(a*(v->X * a + v->Y * b))) / (inv_mass(mA) + inv_mass(mB));
  Vect->Y =  (1+e)*(b*(v->X * a + v->Y * b))  / (inv_mass(mA) + inv_mass(mB));
  return Vect;
}

int isVectorZero(Vector2 v)
{
  return (v->X == 0) && (v->Y) == 0;
}

// Collision Object-limits
void distPlane(Object square)
{
  Vector2 r = calloc(2, sizeof(Vector2));

  if ((square->p->X < -1) && (square->v->X < 0))
    r = reflectionV(1, 0, square->v, square->e, square->w, 0);

  if ((square->p->Y + 32 > HEIGHT) && (-square->v->Y < 0))
    r = reflectionV(0, -1, square->v, square->e, square->w, 0);

  if ((square->p->X + 32 > WIDTH) && (-square->v->X < 0))
    r = reflectionV(-1, 0, square->v, square->e, square->w, 0);

  if ((square->p->Y < -1) && (square->v->Y < 0))
    r = reflectionV(0, 1, square->v, square->e, square->w, 0);

  if (!isVectorZero(r))
    {
      square->v->X -= r->X * inv_mass(square->w);
      square->v->Y -= r->Y * inv_mass(square->w);
    }
}

// Collision Object-Object
void collision(Object squareA, Object squareB)
{
  double dX = pow(((squareA->p->X + 16) - (squareB->p->X + 16)),2);
  double dY = pow(((squareA->p->Y + 16) - (squareB->p->Y + 16)),2);
  if (sqrt(dX + dY) <= 16 + 16)
    {
  Vector2 r = calloc(2, sizeof(Vector2));

      if (squareA->v->X < 0)
        r = reflectionV(1, 0, squareA->v, squareA->e, squareA->w, 0);

      if  (-squareA->v->Y < 0)
        r = reflectionV(0, -1, squareA->v, squareA->e, squareA->w, 0);

      if (-squareA->v->X < 0)
        r = reflectionV(-1, 0, squareA->v, squareA->e, squareA->w, 0);

      if (squareA->v->Y < 0)
        r = reflectionV(0, 1, squareA->v, squareA->e, squareA->w, 0);

      if (!isVectorZero(r))
        {
          squareA->v->X -= r->X * inv_mass(squareA->w);
          squareA->v->Y -= r->Y * inv_mass(squareA->w);
        }
    }
}

double spf(double time, double *update, int frame)
{
  // frame per second
  double fps = ((float)frame / ((SDL_GetTicks() - time) / 1000.f));
  // displaying fps in the taskbar
  char caption[ 64 ];
  sprintf(caption, "Frames Par Seconde: %f", fps);
  SDL_WM_SetCaption(caption, NULL);
  // restarting the timer
  *update = SDL_GetTicks();
  // second per frames : used to compute how much movements must be made
  return ((SDL_GetTicks() - time) / 1000.f) / (float)frame;
}

int main()
{
  srand(time(NULL)); // rand initialization
  size_t quit = 0;

  if(SDL_Init(SDL_INIT_VIDEO) == -1)
    {
      printf("Can't init SDL:  %s\n", SDL_GetError());
      return EXIT_FAILURE;
    }

  SDL_WM_SetCaption("Aerial", NULL);
  SDL_Surface *screen = NULL;
  screen = SDL_SetVideoMode(WIDTH, HEIGHT, BPP, SDL_HWSURFACE);

  if(!screen)
    {
      printf("Can't set video mode: %s\n", SDL_GetError());
      return EXIT_FAILURE;
    }

  Object squares[NUM];
  for (int i = 0; i < NUM; i++)
    {
      squares[i]->p->X = random(0,WIDTH - 32);
      squares[i]->p->Y = random(0,HEIGHT - 32);
      squares[i]->v->X = random(-50,50);
      squares[i]->v->Y = random(-50,50);
      squares[i]->e = random(0.5,1);
      squares[i]->w = random(50,100);
      squares[i]->img = IMG_Load("round.png");
    }


  unsigned int frame = 0;
  double time = SDL_GetTicks();
  double update = SDL_GetTicks();
  double dt = 0;
  while (!quit)
    {
      SDL_FillRect(screen, &screen->clip_rect, SDL_MapRGB(screen->format, 0, 0, 0));

      if (SDL_GetTicks() - update > 1000)
        dt = spf(time, &update, frame);

      for (int i = 0; i < NUM; i++)
        {
          squares[i]->v->Y += 9.8 * dt * 100;

          distPlane(squares[i]);

          for (int j = 0; j < NUM; j++)
            {
              if (j != i)
                collision(squares[i], squares[j]);
            }

          squares[i]->p->X += squares[i]->v->X * dt;
          squares[i]->p->Y += squares[i]->v->Y * dt;

          apply_surface(squares[i]->p->X, squares[i]->p->Y, squares[i]->img, screen);
        }

      // Screen updating
      if(SDL_Flip (screen) == -1)
        return EXIT_FAILURE;

      quit = handleInputs();
      frame++;
    }

  // ========= FREEING ============ //
  for (int i = 0; i < NUM; i++)
    SDL_FreeSurface(squares[i]->img);

  // ========= FREEING ============ //
  SDL_Quit();
  return EXIT_SUCCESS;
}
